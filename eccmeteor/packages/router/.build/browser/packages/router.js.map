{"version":3,"file":"\\packages\\router.js","sources":["router/lib\\router_client.js","router/lib\\router_helpers.js","router/lib\\router_common.js"],"names":[],"mappings":";;;;;;;;AAAA,a;AACA,2B;AACA,sB;AACA,+B;AACA,I;AACA,uB;AACA,6B;AACA,2C;AACA,I;AACA,0B;AACA,G;AACA,E;AACA,wB;AACA,2D;AACA,oB;AACA,Y;AACA,I;AACA,qD;AACA,+D;AACA,0D;AACA,yE;AACA,+E;AACA,sD;AACA,mD;AACA,8C;AACA,uD;AACA,S;AACA,I;AACA,M;AACA,oB;AACA,iC;AACA,uC;AACA,M;AACA,+B;AACA,mE;AACA,M;AACA,wD;AACA,2D;AACA,M;AACA,G;AACA,E;AACA,mD;AACA,oB;AACA,I;AACA,iD;AACA,0C;AACA,8B;AACA,S;AACA,Y;AACA,mD;AACA,6D;AACA,kC;AACA,O;AACA,M;AACA,sE;AACA,qD;AACA,kC;AACA,O;AACA,6D;AACA,M;AACA,2D;AACA,4D;AACA,4F;AACA,U;AACA,K;AACA,G;AACA,E;AACA,4D;AACA,oB;AACA,yD;AACA,I;AACA,sE;AACA,+B;AACA,a;AACA,I;AACA,wE;AACA,uE;AACA,8C;AACA,mC;AACA,I;AACA,0D;AACA,gC;AACA,uD;AACA,mD;AACA,K;AACA,I;AACA,4C;AACA,wE;AACA,sE;AACA,K;AACA,G;AACA,E;AACA,sC;AACA,gC;AACA,sB;AACA,G;AACA,E;AACA,wC;AACA,kB;AACA,0B;AACA,yC;AACA,kB;AACA,iD;AACA,M;AACA,0D;AACA,sD;AACA,K;AACA,I;AACA,e;AACA,G;AACA,E;AACA,mD;AACA,wC;AACA,G;AACA,E;AACA,sB;AACA,K;AACA,4C;AACA,4C;AACA,2D;AACA,kD;AACA,+D;AACA,mE;AACA,mC;AACA,4C;AACA,qD;AACA,oB;AACA,I;AACA,2B;AACA,mD;AACA,kC;AACA,S;AACA,K;AACA,I;AACA,4B;AACA,wB;AACA,kD;AACA,oC;AACA,sD;AACA,wC;AACA,I;AACA,sC;AACA,G;AACA,E;AACA,iD;AACA,yB;AACA,8C;AACA,6B;AACA,G;AACA,E;AACA,8B;AACA,mD;AACA,oB;AACA,iE;AACA,4C;AACA,a;AACA,G;AACA,E;AACA,4D;AACA,0D;AACA,qB;AACA,sB;AACA,2C;AACA,+B;AACA,+C;AACA,K;AACA,U;AACA,gB;AACA,8C;AACA,Y;AACA,kB;AACA,K;AACA,G;AACA,E;AACA,iE;AACA,kD;AACA,iD;AACA,E;AACA,+B;AACA,yC;AACA,K;;;;;;;;;;;;;;;;;;ACpLA,wC;AACA,mE;AACA,2B;AACA,kC;AACA,I;AACA,uB;AACA,6D;AACA,K;AACA,E;AACA,uD;AACA,gC;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACZA,a;AACA,4D;AACA,I;AACA,iE;AACA,I;AACA,K;AACA,kE;AACA,+C;AACA,I;AACA,a;AACA,I;AACA,oD;AACA,mE;AACA,I;AACA,yB;AACA,2B;AACA,6B;AACA,iB;AACA,K;;AAEA,yD;AACA,4B;AACA,qB;AACA,yB;AACA,mC;AACA,sB;AACA,yB;AACA,wB;AACA,G;;AAEA,K;AACA,oE;AACA,uB;AACA,I;AACA,yB;AACA,2B;AACA,0B;AACA,sB;AACA,iB;AACA,K;;AAEA,uE;AACA,mC;AACA,I;AACA,0E;;AAEA,qB;AACA,gC;AACA,wD;AACA,mC;AACA,E;AACA,yB;;AAEA,mD;AACA,4B;;AAEA,uC;AACA,kC;AACA,e;;AAEA,gB;AACA,yD;AACA,4B;AACA,gB;AACA,c;AACA,yB;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qC;AACA,oC;AACA,I;AACA,qC;AACA,uC;AACA,4C;AACA,yB;AACA,I;AACA,uC;AACA,yB;AACA,gC;AACA,6B;AACA,qB;AACA,iB;AACA,K;;AAEA,wD;AACA,4C;AACA,iE;AACA,e;AACA,iC;AACA,+B;AACA,iC;AACA,0G;AACA,wD;AACA,4B;AACA,iB;AACA,mC;AACA,iB;AACA,mC;AACA,qF;AACA,6B;AACA,Q;AACA,kC;AACA,mC;AACA,8B;AACA,I;AACA,8D;AACA,I;AACA,E;AACA,sB;AACA,E;AACA,kE;AACA,E;AACA,K;AACA,6E;AACA,gC;AACA,I;AACA,6E;AACA,I;AACA,2B;AACA,mE;AACA,kB;;AAEA,Y;AACA,yD;AACA,sD;AACA,4B;AACA,I;AACA,sE;AACA,oB;AACA,yB;AACA,c;AACA,yB;AACA,Q;AACA,yE;AACA,iE;AACA,O;AACA,iD;AACA,I;AACA,4B;AACA,I;AACA,8D;AACA,qC;AACA,uC;AACA,c;AACA,M;AACA,8B;AACA,2B;AACA,U;AACA,sB;AACA,M;AACA,yC;AACA,M;AACA,I;AACA,mD;;AAEA,gB;AACA,G;AACA,K","sourcesContent":["(function() {\r\n  var Router = function() {\r\n    this._page = null;\r\n    this._autorunHandle = null;\r\n    \r\n    this._filters = {};\r\n    this._activeFilters = [];\r\n    this._pageDeps = new Deps.Dependency();\r\n    \r\n    this.namedRoutes = {};\r\n  }\r\n  \r\n  // internal, don't use\r\n  Router.prototype._setPageFn = function(pageFn, context) {\r\n    var self = this,\r\n\t\tinterrupt;\r\n    \r\n    // the current function that generates self._page\r\n    // we could just store pageFn and call it everytime someone\r\n    // calls Meteor.Router.page(), but this would lead to \r\n    // the routing function getting called multiple times, which could be\r\n    // unexpected if it has side effects. This is essentially a memoize pattern\r\n    self._autorunHandle && self._autorunHandle.stop();\r\n    self._autorunHandle = Deps.autorun(function() {\r\n      interrupt = self.beforeRouting(context);\r\n\t  if (interrupt != undefined && interrupt === false) {\r\n\t\treturn;\r\n\t  }\r\n      \r\n      var args = [];\r\n      for (key in context.params)\r\n        args.push(context.params[key]);\r\n      \r\n      var oldPage = self._page;\r\n      self._page = self._applyFilters(pageFn.apply(context, args));\r\n      \r\n      // no need to invalidate if .page() hasn't changed\r\n      (oldPage !== self._page) && self._pageDeps.changed();\r\n    })\r\n  }\r\n  \r\n  Router.prototype.add = function(path, endpoint) {\r\n    var self = this;\r\n    \r\n    if (_.isObject(path) && ! _.isRegExp(path)) {\r\n      _.each(path, function(endpoint, p) {\r\n        self.add(p, endpoint);\r\n      });\r\n    } else {\r\n      // '/foo' -> 'bar' <==> '/foo' => {to: 'bar'}\r\n      if (! _.isObject(endpoint) || _.isFunction(endpoint)) {\r\n        endpoint = {to: endpoint};\r\n      }\r\n      \r\n      // route name defaults to template name (unless it's functional)\r\n      if (! endpoint.as && _.isString(endpoint.to)) {\r\n        endpoint.as = endpoint.to;\r\n      }\r\n      endpoint.as && self._setUpNamedRoute(endpoint.as, path)\r\n      \r\n      page(path, _.bind(self._setPageFn, self, function() {\r\n        endpoint.and && endpoint.and.apply(this, arguments);\r\n        return _.isFunction(endpoint.to) ? endpoint.to.apply(this, arguments) : endpoint.to;\r\n      }));\r\n    }\r\n  }\r\n  \r\n  Router.prototype._setUpNamedRoute = function(name, path) {\r\n    var self = this;\r\n    var pathName = name + 'Path', urlName = name + 'Url';\r\n    \r\n    // XXX: I'm not sure there shouldn't be some way to overwrite them\r\n    if (self.namedRoutes[name])\r\n      return;\r\n    \r\n    // XXX: there is some duplication here because page creates it's own\r\n    // route object, but ours has a few extra bits that their's doesn't\r\n    var route = new Meteor.Router.Route(path);\r\n    self.namedRoutes[name] = route;\r\n    \r\n    self[pathName] = _.bind(route.pathWithContext, route);\r\n    self[urlName] = function() {\r\n      var path = self[pathName].apply(self, arguments);\r\n      return Meteor.absoluteUrl(path.substring(1));\r\n    }\r\n    \r\n    if (typeof Handlebars !== 'undefined') {\r\n      Handlebars.registerHelper(pathName, _.bind(self[pathName], self));\r\n      Handlebars.registerHelper(urlName, _.bind(self[urlName], self));\r\n    }\r\n  }\r\n  \r\n  Router.prototype.page = function() {\r\n    Deps.depend(this._pageDeps);\r\n    return this._page;\r\n  }\r\n  \r\n  Router.prototype.to = function(path) {\r\n    // named route\r\n    if (path[0] !== '/') {\r\n      var route = this.namedRoutes[path];\r\n      if (! route)\r\n        throw 'That named route does not exist!';\r\n      \r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      path = route.pathWithContext.apply(route, args);\r\n    }\r\n    \r\n    page(path);\r\n  }\r\n  \r\n  Router.prototype.filters = function(filtersMap) {\r\n    _.extend(this._filters, filtersMap);\r\n  }\r\n  \r\n  // call with one of:\r\n  // \r\n  //   Meteor.Router.filter('filter-name'); \r\n  //     - filter all pages with filter-name\r\n  //   Meteor.Router.filter('filter-name', {only: 'home'});\r\n  //     - filter the 'home' page with filter-name\r\n  //   Meteor.Router.filter('filter-name', {except: ['home']});\r\n  //     - filter all pages except the 'home' page with filter-name\r\n  //   Meteor.Router.filter(object)\r\n  //     -  a map of name: application pairs\r\n  Router.prototype.filter = function(name, options) {\r\n    var self = this;\r\n    \r\n    if (_.isObject(name)) {\r\n      return _.each(name, function(options, key) { \r\n        self.filter(key, options);\r\n      });\r\n    }\r\n    \r\n    options = options || {};\r\n    options.name = name;\r\n    if (options.only && ! _.isArray(options.only))\r\n      options.only = [options.only];\r\n    if (options.except && ! _.isArray(options.except))\r\n      options.except = [options.except];\r\n    \r\n    self._activeFilters.push(options);\r\n  }\r\n  \r\n  // Shouldn't need to use this, more for testing\r\n  // turn off all filters\r\n  Router.prototype.resetFilters = function() {\r\n    this._activeFilters = [];\r\n  }\r\n  \r\n  // run all filters over page\r\n  Router.prototype._applyFilters = function(page) {\r\n    var self = this;\r\n    return _.reduce(self._activeFilters, function(page, filter) {\r\n      return self._applyFilter(page, filter)\r\n    }, page);\r\n  }\r\n  \r\n  // run a single filter (first check only and except apply)\r\n  Router.prototype._applyFilter = function(page, filter) {\r\n    var apply = true;\r\n    if (filter.only) {\r\n      apply = _.include(filter.only, page);\r\n    } else if (filter.except) {\r\n      apply = ! _.include(filter.except, page);\r\n    }\r\n          \r\n    if (apply) {\r\n      return this._filters[filter.name](page);\r\n    } else {\r\n      return page;\r\n    }\r\n  }\r\n  \r\n  // set this to have a function run before each and every route.\r\n  // - the callback should take a context argument\r\n  Router.prototype.beforeRouting = function() {};\r\n  \r\n  Meteor.Router = new Router();\r\n  Meteor.startup(function() { page(); });\r\n}());","if (typeof Handlebars !== 'undefined') {\r\n  Handlebars.registerHelper('renderPage', function(name, options) {\r\n    if (! _.isString(name))\r\n      name = Meteor.Router.page();\r\n    \r\n    if (Template[name])\r\n      return new Handlebars.SafeString(Template[name](this));\r\n  });\r\n  \r\n  Handlebars.registerHelper('currentPage', function() {\r\n    return Meteor.Router.page();\r\n  });\r\n}\r\n","(function() {\r\n  // Route object taken from page.js, slightly stripped down\r\n  //\r\n  // Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\r\n  //\r\n  /**\r\n   * Initialize `Route` with the given HTTP `path`, HTTP `method`,\r\n   * and an array of `callbacks` and `options`.\r\n   *\r\n   * Options:\r\n   *\r\n   *   - `sensitive`    enable case-sensitive routes\r\n   *   - `strict`       enable strict matching for trailing slashes\r\n   *\r\n   * @param {String} path\r\n   * @param {String} method\r\n   * @param {Object} options.\r\n   * @api private\r\n   */\r\n\r\n  Meteor.Router.Route = function(path, method, options) {\r\n    options = options || {};\r\n    this.path = path;\r\n    this.method = method;\r\n    this.regexp = pathtoRegexp(path\r\n      , this.keys = []\r\n      , options.sensitive\r\n      , options.strict);\r\n  }\r\n\r\n  /**\r\n   * Check if this route matches `path` and optional `method`, if so\r\n   * populate `params`.\r\n   *\r\n   * @param {String} path\r\n   * @param {String} method\r\n   * @param {Array} params\r\n   * @return {Boolean}\r\n   * @api private\r\n   */\r\n\r\n  Meteor.Router.Route.prototype.match = function(path, method, params){\r\n    var keys, qsIndex, pathname, m;\r\n    \r\n    if (this.method && this.method.toUpperCase() !== method) return false;\r\n\r\n    keys = this.keys;\r\n    qsIndex = path.indexOf('?');\r\n    pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\r\n    m = this.regexp.exec(pathname);\r\n  \r\n    if (!m) return false;\r\n\r\n    for (var i = 1, len = m.length; i < len; ++i) {\r\n      var key = keys[i - 1];\r\n\r\n      var val = 'string' == typeof m[i]\r\n        ? decodeURIComponent(m[i])\r\n        : m[i];\r\n\r\n      if (key) {\r\n        params[key.name] = undefined !== params[key.name]\r\n          ? params[key.name]\r\n          : val;\r\n      } else {\r\n        params.push(val);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Normalize the given path string,\r\n   * returning a regular expression.\r\n   *\r\n   * An empty array should be passed,\r\n   * which will contain the placeholder\r\n   * key names. For example \"/user/:id\" will\r\n   * then contain [\"id\"].\r\n   *\r\n   * @param  {String|RegExp|Array} path\r\n   * @param  {Array} keys\r\n   * @param  {Boolean} sensitive\r\n   * @param  {Boolean} strict\r\n   * @return {RegExp}\r\n   * @api private\r\n   */\r\n\r\n  function pathtoRegexp(path, keys, sensitive, strict) {\r\n    if (path instanceof RegExp) return path;\r\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\r\n    path = path\r\n      .concat(strict ? '' : '/?')\r\n      .replace(/\\/\\(/g, '(?:/')\r\n      .replace(/\\+/g, '__plus__')\r\n      .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\r\n        keys.push({ name: key, optional: !! optional });\r\n        slash = slash || '';\r\n        return ''\r\n          + (optional ? '' : slash)\r\n          + '(?:'\r\n          + (optional ? slash : '')\r\n          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\r\n          + (optional || '');\r\n      })\r\n      .replace(/([\\/.])/g, '\\\\$1')\r\n      .replace(/__plus__/g, '(.+)')\r\n      .replace(/\\*/g, '(.*)');\r\n    \r\n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\r\n  };\r\n  \r\n  /// END Route object\r\n  \r\n  // Added by tom, lifted from mini-pages, with some modifications\r\n  \r\n  /**\r\n    Given a context object, returns a url path with the values of the context\r\n    object mapped over the path.\r\n    \r\n    Alternatively, supply the named parts of the paths as discrete arguments.\r\n    \r\n    @method pathWithContext\r\n    @param [context] {Object} An optional context object to use for\r\n    interpolation.\r\n\r\n    @example\r\n        // given a page with a path of \"/posts/:_id/edit\"\r\n        var path = page.pathWithContext({ _id: 123 });\r\n        // > /posts/123/edit\r\n  */\r\n  Meteor.Router.Route.prototype.pathWithContext = function (context) {\r\n    var self = this,\r\n        path = self.path,\r\n        parts,\r\n        args = arguments;\r\n        \r\n    /* get an array of keys from the path to replace with context values.\r\n    /* XXX Right now this comes from page-js. Remove dependency. \r\n     */\r\n    parts = self.regexp.exec(self.path).slice(1);\r\n    \r\n    context = context || {};\r\n    \r\n    var replacePathPartWithContextValue = function (part, i) {\r\n      var re = new RegExp(part, \"g\"),\r\n          prop = part.replace(\":\", \"\"),\r\n          val;\r\n      \r\n      if (_.isObject(context))\r\n        val = context[prop]\r\n      else\r\n        val = args[i];\r\n      \r\n      path = path.replace(re, val || '');\r\n    };\r\n    \r\n    _.each(parts, replacePathPartWithContextValue);\r\n\r\n    return path;\r\n  }\r\n}());\r\n"]}