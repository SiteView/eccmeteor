{"version":3,"file":"\\packages\\router.js","sources":["router/lib\\router_server.js","router/lib\\router_common.js"],"names":[],"mappings":";;;;;;;;AAAA,6B;;AAEA,iC;AACA,oD;AACA,Q;AACA,mC;AACA,C;;AAEA,sD;AACA,6C;AACA,Q;AACA,2C;AACA,C;;;AAGA,yB;AACA,oB;AACA,kB;AACA,qC;AACA,I;AACA,wB;AACA,E;;AAEA,0C;AACA,0D;AACA,kB;;AAEA,sC;AACA,qB;AACA,kB;AACA,G;;AAEA,+C;AACA,wC;AACA,4B;AACA,O;AACA,U;AACA,qB;AACA,qE;AACA,wB;AACA,oB;AACA,K;AACA,mC;AACA,oD;AACA,K;AACA,yE;AACA,G;AACA,E;;AAEA,sD;AACA,iD;AACA,6C;;AAEA,8D;AACA,uE;;AAEA,oB;AACA,qC;AACA,uC;;AAEA,2C;AACA,K;AACA,G;;AAEA,e;AACA,E;;AAEA,+C;AACA,oB;AACA,6F;AACA,G;;AAEA,gD;AACA,E;;AAEA,qC;AACA,kB;;AAEA,oB;AACA,uD;AACA,G;;AAEA,uB;;AAEA,wB;AACA,iB;AACA,6E;AACA,6D;AACA,mC;AACA,gE;AACA,+B;AACA,mE;;AAEA,wB;AACA,mD;;AAEA,+B;AACA,wB;AACA,gB;AACA,+D;;AAEA,yB;AACA,qE;AACA,kC;AACA,iE;AACA,qC;;AAEA,sC;AACA,mD;AACA,oD;AACA,0C;AACA,iB;AACA,a;;AAEA,sC;AACA,8C;AACA,a;;AAEA,+B;AACA,W;;AAEA,mC;AACA,oC;AACA,wB;AACA,W;;AAEA,iC;AACA,S;AACA,e;AACA,O;AACA,E;;AAEA,4B;AACA,6B;;;;;;;;;;;;;;;;;;;ACrIA,a;AACA,4D;AACA,I;AACA,iE;AACA,I;AACA,K;AACA,kE;AACA,+C;AACA,I;AACA,a;AACA,I;AACA,oD;AACA,mE;AACA,I;AACA,yB;AACA,2B;AACA,6B;AACA,iB;AACA,K;;AAEA,yD;AACA,4B;AACA,qB;AACA,yB;AACA,mC;AACA,sB;AACA,yB;AACA,wB;AACA,G;;AAEA,K;AACA,oE;AACA,uB;AACA,I;AACA,yB;AACA,2B;AACA,0B;AACA,sB;AACA,iB;AACA,K;;AAEA,uE;AACA,mC;AACA,I;AACA,0E;;AAEA,qB;AACA,gC;AACA,wD;AACA,mC;AACA,E;AACA,yB;;AAEA,mD;AACA,4B;;AAEA,uC;AACA,kC;AACA,e;;AAEA,gB;AACA,yD;AACA,4B;AACA,gB;AACA,c;AACA,yB;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qC;AACA,oC;AACA,I;AACA,qC;AACA,uC;AACA,4C;AACA,yB;AACA,I;AACA,uC;AACA,yB;AACA,gC;AACA,6B;AACA,qB;AACA,iB;AACA,K;;AAEA,wD;AACA,4C;AACA,iE;AACA,e;AACA,iC;AACA,+B;AACA,iC;AACA,0G;AACA,wD;AACA,4B;AACA,iB;AACA,mC;AACA,iB;AACA,mC;AACA,qF;AACA,6B;AACA,Q;AACA,kC;AACA,mC;AACA,8B;AACA,I;AACA,8D;AACA,I;AACA,E;AACA,sB;AACA,E;AACA,kE;AACA,E;AACA,K;AACA,6E;AACA,gC;AACA,I;AACA,6E;AACA,I;AACA,2B;AACA,mE;AACA,kB;;AAEA,Y;AACA,yD;AACA,sD;AACA,4B;AACA,I;AACA,sE;AACA,oB;AACA,yB;AACA,c;AACA,yB;AACA,Q;AACA,yE;AACA,iE;AACA,O;AACA,iD;AACA,I;AACA,4B;AACA,I;AACA,8D;AACA,qC;AACA,uC;AACA,c;AACA,M;AACA,8B;AACA,2B;AACA,U;AACA,sB;AACA,M;AACA,yC;AACA,M;AACA,I;AACA,mD;;AAEA,gB;AACA,G;AACA,K","sourcesContent":["var connectHandlers, connect;\r\n\r\nif (typeof(Npm) == \"undefined\") {\r\n  connect = __meteor_bootstrap__.require(\"connect\");\r\n} else {\r\n  connect = Npm.require(\"connect\");\r\n}\r\n\r\nif (typeof __meteor_bootstrap__.app !== 'undefined') {\r\n  connectHandlers = __meteor_bootstrap__.app;\r\n} else {\r\n  connectHandlers = WebApp.connectHandlers;\r\n}\r\n\r\n\r\nvar Router = function() {\r\n  this._routes = [];\r\n  this._config = {\r\n    requestParser: connect.bodyParser\r\n  };\r\n  this._started = false;\r\n};\r\n\r\n// simply match this path to this function\r\nRouter.prototype.add = function(path, method, endpoint)  {\r\n  var self = this;\r\n\r\n  // Start serving on first add() call\r\n  if(!this._started){\r\n    this._start();\r\n  }\r\n\r\n  if (_.isObject(path) && ! _.isRegExp(path)) {\r\n    _.each(path, function(endpoint, p) {\r\n      self.add(p, endpoint);\r\n    });\r\n  } else {\r\n    if (! endpoint) {\r\n      // no http method was supplied so 2nd parameter is the endpoint\r\n      endpoint = method;\r\n      method = null;\r\n    }\r\n    if (! _.isFunction(endpoint)) {\r\n      endpoint = _.bind(_.identity, null, endpoint);\r\n    }\r\n    self._routes.push([new Meteor.Router.Route(path, method), endpoint]);\r\n  }\r\n};\r\n\r\nRouter.prototype.match = function(request, response) {\r\n  for (var i = 0; i < this._routes.length; i++) {\r\n    var params = [], route = this._routes[i];\r\n\r\n    if (route[0].match(request.url, request.method, params)) {\r\n      context = {request: request, response: response, params: params};\r\n\r\n      var args = [];\r\n      for (var key in context.params)\r\n        args.push(context.params[key]);\r\n\r\n      return route[1].apply(context, args);\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nRouter.prototype.configure = function(config) {\r\n  if(this._started){\r\n    throw new Error(\"Router.configure() has to be called before first call to Router.add()\");\r\n  }\r\n\r\n  this._config = _.extend(this._config, config);\r\n};\r\n\r\nRouter.prototype._start = function(){\r\n  var self = this;\r\n\r\n  if(this._started){\r\n    throw new Error(\"Router has already been started\");\r\n  }\r\n\r\n  this._started = true;\r\n\r\n  // hook up the serving\r\n  connectHandlers\r\n    .use(connect.query()) // <- XXX: we can probably assume accounts did this\r\n    .use(this._config.requestParser(this._config.bodyParser))\r\n    .use(function(req, res, next) {\r\n      // need to wrap in a fiber in case they do something async\r\n      // (e.g. in the database)\r\n      if(typeof(Fiber)==\"undefined\") Fiber = Npm.require('fibers');\r\n\r\n      Fiber(function() {\r\n        var output = Meteor.Router.match(req, res);\r\n\r\n        if (output === false) {\r\n          return next();\r\n        } else {\r\n          // parse out the various type of response we can have\r\n\r\n          // array can be\r\n          // [content], [status, content], [status, headers, content]\r\n          if (_.isArray(output)) {\r\n            // copy the array so we aren't actually modifying it!\r\n            output = output.slice(0);\r\n\r\n            if (output.length === 3) {\r\n              var headers = output.splice(1, 1)[0];\r\n              _.each(headers, function(value, key) {\r\n                res.setHeader(key, value);\r\n              });\r\n            }\r\n\r\n            if (output.length === 2) {\r\n              res.statusCode = output.shift();\r\n            }\r\n\r\n            output = output[0];\r\n          }\r\n\r\n          if (_.isNumber(output)) {\r\n            res.statusCode = output;\r\n            output = '';\r\n          }\r\n\r\n          return res.end(output);\r\n        }\r\n      }).run();\r\n    });\r\n};\r\n\r\n// Make the router available\r\nMeteor.Router = new Router();\r\n","(function() {\r\n  // Route object taken from page.js, slightly stripped down\r\n  //\r\n  // Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\r\n  //\r\n  /**\r\n   * Initialize `Route` with the given HTTP `path`, HTTP `method`,\r\n   * and an array of `callbacks` and `options`.\r\n   *\r\n   * Options:\r\n   *\r\n   *   - `sensitive`    enable case-sensitive routes\r\n   *   - `strict`       enable strict matching for trailing slashes\r\n   *\r\n   * @param {String} path\r\n   * @param {String} method\r\n   * @param {Object} options.\r\n   * @api private\r\n   */\r\n\r\n  Meteor.Router.Route = function(path, method, options) {\r\n    options = options || {};\r\n    this.path = path;\r\n    this.method = method;\r\n    this.regexp = pathtoRegexp(path\r\n      , this.keys = []\r\n      , options.sensitive\r\n      , options.strict);\r\n  }\r\n\r\n  /**\r\n   * Check if this route matches `path` and optional `method`, if so\r\n   * populate `params`.\r\n   *\r\n   * @param {String} path\r\n   * @param {String} method\r\n   * @param {Array} params\r\n   * @return {Boolean}\r\n   * @api private\r\n   */\r\n\r\n  Meteor.Router.Route.prototype.match = function(path, method, params){\r\n    var keys, qsIndex, pathname, m;\r\n    \r\n    if (this.method && this.method.toUpperCase() !== method) return false;\r\n\r\n    keys = this.keys;\r\n    qsIndex = path.indexOf('?');\r\n    pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\r\n    m = this.regexp.exec(pathname);\r\n  \r\n    if (!m) return false;\r\n\r\n    for (var i = 1, len = m.length; i < len; ++i) {\r\n      var key = keys[i - 1];\r\n\r\n      var val = 'string' == typeof m[i]\r\n        ? decodeURIComponent(m[i])\r\n        : m[i];\r\n\r\n      if (key) {\r\n        params[key.name] = undefined !== params[key.name]\r\n          ? params[key.name]\r\n          : val;\r\n      } else {\r\n        params.push(val);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Normalize the given path string,\r\n   * returning a regular expression.\r\n   *\r\n   * An empty array should be passed,\r\n   * which will contain the placeholder\r\n   * key names. For example \"/user/:id\" will\r\n   * then contain [\"id\"].\r\n   *\r\n   * @param  {String|RegExp|Array} path\r\n   * @param  {Array} keys\r\n   * @param  {Boolean} sensitive\r\n   * @param  {Boolean} strict\r\n   * @return {RegExp}\r\n   * @api private\r\n   */\r\n\r\n  function pathtoRegexp(path, keys, sensitive, strict) {\r\n    if (path instanceof RegExp) return path;\r\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\r\n    path = path\r\n      .concat(strict ? '' : '/?')\r\n      .replace(/\\/\\(/g, '(?:/')\r\n      .replace(/\\+/g, '__plus__')\r\n      .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\r\n        keys.push({ name: key, optional: !! optional });\r\n        slash = slash || '';\r\n        return ''\r\n          + (optional ? '' : slash)\r\n          + '(?:'\r\n          + (optional ? slash : '')\r\n          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\r\n          + (optional || '');\r\n      })\r\n      .replace(/([\\/.])/g, '\\\\$1')\r\n      .replace(/__plus__/g, '(.+)')\r\n      .replace(/\\*/g, '(.*)');\r\n    \r\n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\r\n  };\r\n  \r\n  /// END Route object\r\n  \r\n  // Added by tom, lifted from mini-pages, with some modifications\r\n  \r\n  /**\r\n    Given a context object, returns a url path with the values of the context\r\n    object mapped over the path.\r\n    \r\n    Alternatively, supply the named parts of the paths as discrete arguments.\r\n    \r\n    @method pathWithContext\r\n    @param [context] {Object} An optional context object to use for\r\n    interpolation.\r\n\r\n    @example\r\n        // given a page with a path of \"/posts/:_id/edit\"\r\n        var path = page.pathWithContext({ _id: 123 });\r\n        // > /posts/123/edit\r\n  */\r\n  Meteor.Router.Route.prototype.pathWithContext = function (context) {\r\n    var self = this,\r\n        path = self.path,\r\n        parts,\r\n        args = arguments;\r\n        \r\n    /* get an array of keys from the path to replace with context values.\r\n    /* XXX Right now this comes from page-js. Remove dependency. \r\n     */\r\n    parts = self.regexp.exec(self.path).slice(1);\r\n    \r\n    context = context || {};\r\n    \r\n    var replacePathPartWithContextValue = function (part, i) {\r\n      var re = new RegExp(part, \"g\"),\r\n          prop = part.replace(\":\", \"\"),\r\n          val;\r\n      \r\n      if (_.isObject(context))\r\n        val = context[prop]\r\n      else\r\n        val = args[i];\r\n      \r\n      path = path.replace(re, val || '');\r\n    };\r\n    \r\n    _.each(parts, replacePathPartWithContextValue);\r\n\r\n    return path;\r\n  }\r\n}());\r\n"]}